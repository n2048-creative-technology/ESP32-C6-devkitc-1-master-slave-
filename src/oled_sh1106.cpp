#include "../include/oled_sh1106.h"

#include <string.h>

#include "esp_log.h"
#include "freertos/FreeRTOS.h"

static const char *TAG = "oled";

static i2c_port_t s_port = I2C_NUM_0;
static uint8_t s_addr = 0x3C;
static bool s_ready = false;

static uint8_t s_buf[128 * 64 / 8] = {0};

static const uint8_t kFont5x7[96][5] = {
    {0x00, 0x00, 0x00, 0x00, 0x00}, {0x00, 0x00, 0x5F, 0x00, 0x00},
    {0x00, 0x07, 0x00, 0x07, 0x00}, {0x14, 0x7F, 0x14, 0x7F, 0x14},
    {0x24, 0x2A, 0x7F, 0x2A, 0x12}, {0x23, 0x13, 0x08, 0x64, 0x62},
    {0x36, 0x49, 0x55, 0x22, 0x50}, {0x00, 0x05, 0x03, 0x00, 0x00},
    {0x00, 0x1C, 0x22, 0x41, 0x00}, {0x00, 0x41, 0x22, 0x1C, 0x00},
    {0x14, 0x08, 0x3E, 0x08, 0x14}, {0x08, 0x08, 0x3E, 0x08, 0x08},
    {0x00, 0x50, 0x30, 0x00, 0x00}, {0x08, 0x08, 0x08, 0x08, 0x08},
    {0x00, 0x60, 0x60, 0x00, 0x00}, {0x20, 0x10, 0x08, 0x04, 0x02},
    {0x3E, 0x51, 0x49, 0x45, 0x3E}, {0x00, 0x42, 0x7F, 0x40, 0x00},
    {0x42, 0x61, 0x51, 0x49, 0x46}, {0x21, 0x41, 0x45, 0x4B, 0x31},
    {0x18, 0x14, 0x12, 0x7F, 0x10}, {0x27, 0x45, 0x45, 0x45, 0x39},
    {0x3C, 0x4A, 0x49, 0x49, 0x30}, {0x01, 0x71, 0x09, 0x05, 0x03},
    {0x36, 0x49, 0x49, 0x49, 0x36}, {0x06, 0x49, 0x49, 0x29, 0x1E},
    {0x00, 0x36, 0x36, 0x00, 0x00}, {0x00, 0x56, 0x36, 0x00, 0x00},
    {0x08, 0x14, 0x22, 0x41, 0x00}, {0x14, 0x14, 0x14, 0x14, 0x14},
    {0x00, 0x41, 0x22, 0x14, 0x08}, {0x02, 0x01, 0x51, 0x09, 0x06},
    {0x32, 0x49, 0x79, 0x41, 0x3E}, {0x7E, 0x11, 0x11, 0x11, 0x7E},
    {0x7F, 0x49, 0x49, 0x49, 0x36}, {0x3E, 0x41, 0x41, 0x41, 0x22},
    {0x7F, 0x41, 0x41, 0x22, 0x1C}, {0x7F, 0x49, 0x49, 0x49, 0x41},
    {0x7F, 0x09, 0x09, 0x09, 0x01}, {0x3E, 0x41, 0x49, 0x49, 0x7A},
    {0x7F, 0x08, 0x08, 0x08, 0x7F}, {0x00, 0x41, 0x7F, 0x41, 0x00},
    {0x20, 0x40, 0x41, 0x3F, 0x01}, {0x7F, 0x08, 0x14, 0x22, 0x41},
    {0x7F, 0x40, 0x40, 0x40, 0x40}, {0x7F, 0x02, 0x04, 0x02, 0x7F},
    {0x7F, 0x04, 0x08, 0x10, 0x7F}, {0x3E, 0x41, 0x41, 0x41, 0x3E},
    {0x7F, 0x09, 0x09, 0x09, 0x06}, {0x3E, 0x41, 0x51, 0x21, 0x5E},
    {0x7F, 0x09, 0x19, 0x29, 0x46}, {0x46, 0x49, 0x49, 0x49, 0x31},
    {0x01, 0x01, 0x7F, 0x01, 0x01}, {0x3F, 0x40, 0x40, 0x40, 0x3F},
    {0x1F, 0x20, 0x40, 0x20, 0x1F}, {0x3F, 0x40, 0x38, 0x40, 0x3F},
    {0x63, 0x14, 0x08, 0x14, 0x63}, {0x07, 0x08, 0x70, 0x08, 0x07},
    {0x61, 0x51, 0x49, 0x45, 0x43}, {0x00, 0x7F, 0x41, 0x41, 0x00},
    {0x02, 0x04, 0x08, 0x10, 0x20}, {0x00, 0x41, 0x41, 0x7F, 0x00},
    {0x04, 0x02, 0x01, 0x02, 0x04}, {0x40, 0x40, 0x40, 0x40, 0x40},
    {0x00, 0x01, 0x02, 0x04, 0x00}, {0x20, 0x54, 0x54, 0x54, 0x78},
    {0x7F, 0x48, 0x44, 0x44, 0x38}, {0x38, 0x44, 0x44, 0x44, 0x20},
    {0x38, 0x44, 0x44, 0x48, 0x7F}, {0x38, 0x54, 0x54, 0x54, 0x18},
    {0x08, 0x7E, 0x09, 0x01, 0x02}, {0x0C, 0x52, 0x52, 0x52, 0x3E},
    {0x7F, 0x08, 0x04, 0x04, 0x78}, {0x00, 0x44, 0x7D, 0x40, 0x00},
    {0x20, 0x40, 0x44, 0x3D, 0x00}, {0x7F, 0x10, 0x28, 0x44, 0x00},
    {0x00, 0x41, 0x7F, 0x40, 0x00}, {0x7C, 0x04, 0x18, 0x04, 0x78},
    {0x7C, 0x08, 0x04, 0x04, 0x78}, {0x38, 0x44, 0x44, 0x44, 0x38},
    {0x7C, 0x14, 0x14, 0x14, 0x08}, {0x08, 0x14, 0x14, 0x18, 0x7C},
    {0x7C, 0x08, 0x04, 0x04, 0x08}, {0x48, 0x54, 0x54, 0x54, 0x20},
    {0x04, 0x3F, 0x44, 0x40, 0x20}, {0x3C, 0x40, 0x40, 0x20, 0x7C},
    {0x1C, 0x20, 0x40, 0x20, 0x1C}, {0x3C, 0x40, 0x30, 0x40, 0x3C},
    {0x44, 0x28, 0x10, 0x28, 0x44}, {0x0C, 0x50, 0x50, 0x50, 0x3C},
    {0x44, 0x64, 0x54, 0x4C, 0x44}, {0x00, 0x08, 0x36, 0x41, 0x00},
    {0x00, 0x00, 0x7F, 0x00, 0x00}, {0x00, 0x41, 0x36, 0x08, 0x00},
    {0x02, 0x01, 0x02, 0x04, 0x02}, {0x00, 0x00, 0x00, 0x00, 0x00}};

static esp_err_t writeCmd(uint8_t cmd) {
  uint8_t data[2] = {0x00, cmd};
  return i2c_master_write_to_device(s_port, s_addr, data, sizeof(data), 50 / portTICK_PERIOD_MS);
}

static esp_err_t writeData(const uint8_t *data, size_t len) {
  uint8_t header = 0x40;
  i2c_cmd_handle_t cmd = i2c_cmd_link_create();
  i2c_master_start(cmd);
  i2c_master_write_byte(cmd, (s_addr << 1) | I2C_MASTER_WRITE, true);
  i2c_master_write(cmd, &header, 1, true);
  i2c_master_write(cmd, data, len, true);
  i2c_master_stop(cmd);
  esp_err_t ret = i2c_master_cmd_begin(s_port, cmd, 50 / portTICK_PERIOD_MS);
  i2c_cmd_link_delete(cmd);
  return ret;
}

bool oledInit(i2c_port_t port, int sda_gpio, int scl_gpio, uint8_t address) {
  s_port = port;
  s_addr = address;

  i2c_config_t conf = {};
  conf.mode = I2C_MODE_MASTER;
  conf.sda_io_num = (gpio_num_t)sda_gpio;
  conf.scl_io_num = (gpio_num_t)scl_gpio;
  conf.sda_pullup_en = GPIO_PULLUP_ENABLE;
  conf.scl_pullup_en = GPIO_PULLUP_ENABLE;
  conf.master.clk_speed = 400000;
  esp_err_t ret = i2c_param_config(s_port, &conf);
  if (ret != ESP_OK) {
    ESP_LOGW(TAG, "i2c config failed err=%d", (int)ret);
    return false;
  }
  ret = i2c_driver_install(s_port, conf.mode, 0, 0, 0);
  if (ret != ESP_OK && ret != ESP_ERR_INVALID_STATE) {
    ESP_LOGW(TAG, "i2c install failed err=%d", (int)ret);
    return false;
  }

  writeCmd(0xAE);
  writeCmd(0xD5);
  writeCmd(0x80);
  writeCmd(0xA8);
  writeCmd(0x3F);
  writeCmd(0xD3);
  writeCmd(0x00);
  writeCmd(0x40);
  writeCmd(0xAD);
  writeCmd(0x8B);
  writeCmd(0xA1);
  writeCmd(0xC8);
  writeCmd(0xDA);
  writeCmd(0x12);
  writeCmd(0x81);
  writeCmd(0x7F);
  writeCmd(0xD9);
  writeCmd(0x22);
  writeCmd(0xDB);
  writeCmd(0x35);
  writeCmd(0xA4);
  writeCmd(0xA6);
  writeCmd(0xAF);

  memset(s_buf, 0, sizeof(s_buf));
  s_ready = true;
  oledUpdate();
  return true;
}

void oledClear() {
  memset(s_buf, 0, sizeof(s_buf));
}

static void setPixel(int x, int y, bool on) {
  if (x < 0 || x >= 128 || y < 0 || y >= 64) {
    return;
  }
  size_t idx = (size_t)x + (size_t)(y / 8) * 128;
  uint8_t mask = (uint8_t)(1u << (y & 7));
  if (on) {
    s_buf[idx] |= mask;
  } else {
    s_buf[idx] &= (uint8_t)~mask;
  }
}

static void drawChar(int x, int y, char c) {
  if (c < 32 || c > 127) {
    c = '?';
  }
  const uint8_t *bitmap = kFont5x7[c - 32];
  for (int col = 0; col < 5; ++col) {
    uint8_t line = bitmap[col];
    for (int row = 0; row < 7; ++row) {
      bool on = (line >> row) & 0x01;
      setPixel(x + col, y + row, on);
    }
  }
}

void oledDrawString(int x, int y, const char *text) {
  if (!text) {
    return;
  }
  int cursor = x;
  for (const char *p = text; *p; ++p) {
    drawChar(cursor, y, *p);
    cursor += 6;
    if (cursor >= 128) {
      break;
    }
  }
}

void oledUpdate() {
  if (!s_ready) {
    return;
  }
  for (int page = 0; page < 8; ++page) {
    writeCmd(0xB0 + page);
    writeCmd(0x02);
    writeCmd(0x10);
    const uint8_t *ptr = &s_buf[page * 128];
    writeData(ptr, 128);
  }
}
